# -*- coding: utf-8 -*-
"""ibm m1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1KrScLhl5vcEN06goqpYB7vke4tv8Fyl2
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

df=pd.read_table("/content/drive/MyDrive/Restaurant_Reviews data set.tsv")
df                #It will show the output like this. It will show the first five and last five rows and also it will show the number of rows and number of columns in the data frame.

df.info() #info() method gives the information about the data frame.
          #I will give the number of columns, column labels, number of non-null entries, the data type of the column, memory usage.

df.describe() #It will give total count, mean, standard deviation, minimum value, maximum value, 25% of data, 50% of data, 75% of data.

df.columns

df['Liked'].nunique() #nunique() method gives the number of unique values in the particular column

print(df['Liked'].unique()) #unique() method gives unique values in the particular column.

df['Liked'].value_counts() #value_counts() method gives the number of times the particular value repeated in that column through the data frame.

df.head()

plt.figure(figsize=(8,5))
sns.countplot(x=df.Liked);

x=df['Review'].values
y=df['Liked'].values

from sklearn.model_selection import train_test_split      #Split the Dataset into Training and Testing Sets
x_train,x_test,y_train,y_test=train_test_split(x,y,random_state=0)

#View the Shapes of Train Sets and Test Sets
x_train.shape

x_test.shape

y_train.shape

y_test.shape

from sklearn.feature_extraction.text import CountVectorizer
vect=CountVectorizer(stop_words='english')
x_train_vect=vect.fit_transform(x_train)
x_test_vect=vect.transform(x_test)

from sklearn.svm import SVC
model=SVC()

model.fit(x_train_vect,y_train)

y_pred=model.predict(x_test_vect)

from sklearn.metrics import accuracy_score
from sklearn.metrics import precision_score
from sklearn.metrics import recall_score
a=accuracy_score(y_pred,y_test)
b=precision_score(y_pred,y_test)
c=recall_score(y_pred,y_test)
print(round(a*100,2))
print(round(b*100,2))
print(round(c*100,2))

from sklearn.pipeline import make_pipeline
text_model=make_pipeline(CountVectorizer(),SVC())

a=text_model.fit(x_train,y_train)

y_pred=text_model.predict(x_test)
y_pred

accuracy_score(y_pred,y_test) #The accuracy of the model is 79.2%.

import joblib
joblib.dump(text_model,'Project')

import joblib
text_model=joblib.load('Project')

text_model.predict(['hello!!Love Your Food']) #Here the review is a positive review and as expected our model predicted 1 for it which means positive.

text_model.predict(["omg!!it was too spice and i asked you don't add too much "]) #As expected it gave 0 as output which means negative.

"""**`Logistic Regression Model**"""

import nltk
import re
nltk.download('stopwords')
from nltk.corpus import stopwords
from nltk.stem.porter import PorterStemmer

corpus=[]
for z in range(0,1000):
    review=re.sub(pattern='[^a-zA-Z]',repl=' ',string=df['Review'][z])
    review=review.lower()
    review_words=review.split()
    review_words=[word for word in review_words if not word in set (stopwords.words('english'))]
    ps=PorterStemmer()
    review=[ps.stem(word) for word in review_words]
    review=' '.join(review)
    corpus.append(review)

corpus[:1500]

from sklearn.feature_extraction.text import CountVectorizer
cv=CountVectorizer(max_features=1500)
m=cv.fit_transform(corpus).toarray()
n=df.iloc[:,-1].values

len(m[0 ])

def predict_statement(sample_review):
  sample_review = re.sub(pattern = '[^a-zA-Z]',repl =' ',string=sample_review)
  sample_review = sample_review.lower()
  sample_review_words = sample_review.split()
  sample_review_words = [word for word in sample_review_words if not word in set(stopwords.words('english'))]
  ps = PorterStemmer()
  final_review = [ps.stem(word) for word in sample_review_words]
  final_review =' '.join(final_review)
  temp = cv.transform([final_review]).toarray()
  return classifier.predict(temp)

from sklearn.model_selection import train_test_split
x_train, x_test, y_train, y_test=train_test_split(m,n,test_size=0.3,random_state=42)

x_train.shape, x_test.shape, y_train.shape, y_test.shape

from sklearn.feature_extraction.text import CountVectorizer
cv=CountVectorizer(max_features=1500)
m=cv.fit_transform(corpus).toarray()
n=df.iloc[:,-1].values

from sklearn import linear_model
classifier = linear_model.LogisticRegression(C=1.5)
classifier.fit(x_train, y_train)

# Predicting the Test set results
y_pred1 = classifier.predict(x_test)
y_pred1

#Making the Confusion Matrix
from sklearn.metrics import confusion_matrix
cm1 = confusion_matrix(y_test, y_pred1)
print ("Confusion Matrix:\n",cm1)

# Commented out IPython magic to ensure Python compatibility.
from ast import increment_lineno
import matplotlib.pyplot as plt
import seaborn as sns
# %matplotlib inline
plt.figure(figsize=(10,6))
sns.heatmap(cm1,annot=True,cmap="YlGnBu",xticklabels=['Negative','Positive'],yticklabels=['Negative','Positive'])
plt.xlabel('Predicted values')
plt.ylabel('actual values')

from sklearn.metrics import accuracy_score
from sklearn.metrics import precision_score
from sklearn.metrics import recall_score
d = accuracy_score(y_test,y_pred1)
e = precision_score(y_test,y_pred1)
f= recall_score(y_test,y_pred1)
print("\n")
print("Accuracy is ",round(d*100,2),"%")
print("Precision is ",round(e*100,2),"%")
print("Recall is ",round(f*100,2),"%")

from sklearn.metrics import accuracy_score
accuracy=accuracy_score(y_test,y_pred1)
print("Accuracy =",accuracy*100,"%")

sample_review = 'The food is really bad.'
if predict_statement(sample_review):
  print("This is a positive review.")
else:
  print("This is a negative review!")

sample_review = "The food was absolutely wonderful, from preparation to presentation, very pleasing."
if predict_statement(sample_review):
  print("This is a POSITIVE review.")
else:
  print("This is a NEGATIVE review!")

